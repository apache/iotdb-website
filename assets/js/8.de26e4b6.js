(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{531:function(e,t,s){},562:function(e,t,s){"use strict";s(531)},618:function(e,t,s){"use strict";s.r(t);s(562);var i=s(68),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"tsfile-read-process"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tsfile-read-process"}},[e._v("#")]),e._v(" TsFile Read Process")]),e._v(" "),s("p",[e._v("This chapter introduces how to read TsFile. The content is mainly divided into two parts, the introduction of Filters and Expressions , and the detailed illustration of query process in TsFile.")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#TsFile-Read-Process"}},[e._v("TsFile Read Process")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#1-Filters-and-Expressions"}},[e._v("1 Filters and Expressions")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#11-Filter"}},[e._v("1.1 Filter")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#12-Expression"}},[e._v("1.2 Expression")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#121-SingleSeriesExpression"}},[e._v("1.2.1 SingleSeriesExpression")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#122-GlobalTimeExpression"}},[e._v("1.2.2 GlobalTimeExpression")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#123-IExpression"}},[e._v("1.2.3 IExpression")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#124-Executable-Expression"}},[e._v("1.2.4 Executable Expression")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#125-The-Algorithm-Transforming-IExpression-to-an-Executable-Expression"}},[e._v("1.2.5 The Algorithm Transforming IExpression to an Executable Expression")])])])])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#2-Query-Execution-of-TsFile"}},[e._v("2 Query Execution of TsFile")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#21-Design"}},[e._v("2.1 Design")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#22-Three-Components"}},[e._v("2.2 Three Components")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#221-FileSeriesReader"}},[e._v("2.2.1 FileSeriesReader")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#222-FileSeriesReaderByTimestamp"}},[e._v("2.2.2 FileSeriesReaderByTimestamp")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#223-TimeGeneratorImpl"}},[e._v("2.2.3 TimeGeneratorImpl")])])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#23-Merge-Query"}},[e._v("2.3 Merge Query")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#24-Join-Query"}},[e._v("2.4 Join Query")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#25-Query-of-TsFile"}},[e._v("2.5 Query of TsFile")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#26-Related-Concepts"}},[e._v("2.6 Related Concepts")])])])])])])]),e._v(" "),s("h2",{attrs:{id:"_1-filters-and-expressions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-filters-and-expressions"}},[e._v("#")]),e._v(" 1 Filters and Expressions")]),e._v(" "),s("h3",{attrs:{id:"_1-1-filter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-filter"}},[e._v("#")]),e._v(" 1.1 Filter")]),e._v(" "),s("p",[e._v("In this document, the term Filter means filter conditions. Users can customize filter conditions on timestamp, or the value of time series. We distinguish the filters which are on timestamp from those on column values. Assume t to be a timestamp constant, there are 12 basic types of Filters. In implementation, they all inherit from the super class Filter.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Filter")]),e._v(" "),s("th",[e._v("Filter Type")]),e._v(" "),s("th",[e._v("Explanation")]),e._v(" "),s("th",[e._v("Examples")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("TimeEq")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp = some value")]),e._v(" "),s("td",[e._v("TimeEq(t) means timestamp should be equal to t")])]),e._v(" "),s("tr",[s("td",[e._v("TimeGt")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp > some value")]),e._v(" "),s("td",[e._v("TimeGt(t) means timestamp should be greater than t")])]),e._v(" "),s("tr",[s("td",[e._v("TimeGtEq")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp >= some value")]),e._v(" "),s("td",[e._v("TimeGtEq(t) means timestamp greater than or equal to t")])]),e._v(" "),s("tr",[s("td",[e._v("TimeLt")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp < some value")]),e._v(" "),s("td",[e._v("TimeLt(t) means timestamp should be less than t")])]),e._v(" "),s("tr",[s("td",[e._v("TimeLtEq")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp <= some value")]),e._v(" "),s("td",[e._v("TimeLtEq(t) means timestamp should be less than or equal to t")])]),e._v(" "),s("tr",[s("td",[e._v("TimeNotEq")]),e._v(" "),s("td",[e._v("time filter")]),e._v(" "),s("td",[e._v("timestamp != some value")]),e._v(" "),s("td",[e._v("TimeNotEq(t) means timestamp should not be equal to t")])]),e._v(" "),s("tr",[s("td",[e._v("ValueEq")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column = some value")]),e._v(" "),s("td",[e._v("ValueEq(2147483649) means value on this column should be equal to 2147483649")])]),e._v(" "),s("tr",[s("td",[e._v("ValueGt")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column > some value")]),e._v(" "),s("td",[e._v("ValueGt(100.5) means value on this column should be greater than 100.5")])]),e._v(" "),s("tr",[s("td",[e._v("ValueGtEq")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column >= some value")]),e._v(" "),s("td",[e._v("ValueGtEq(2) means value on this column should be greanter than 2")])]),e._v(" "),s("tr",[s("td",[e._v("ValueLt")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column < some value")]),e._v(" "),s("td",[e._v('ValueLt("string") means value on this column should be less than "string" in alphabet order')])]),e._v(" "),s("tr",[s("td",[e._v("ValueLtEq")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column <= some value")]),e._v(" "),s("td",[e._v("ValueLtEq(-100) means value on this column shold be less than or equal to -100")])]),e._v(" "),s("tr",[s("td",[e._v("ValueNotEq")]),e._v(" "),s("td",[e._v("value filter")]),e._v(" "),s("td",[e._v("value on this column != some value")]),e._v(" "),s("td",[e._v("ValueNotEq(true) means value on this column should not be true")])])])]),e._v(" "),s("p",[e._v("Filter can be composed of one or two Filter children。If a Filter is composed of a single Filter, it is also termed as UnaryFilter.If it contains two filters, it is termed as BinaryFilter. In this case, the two filters are connected with a logical relation, AND or OR, where the formar is termed as AndFilter, and the latter is OrFilter. Obviously, both AndFilter and OrFilter are BinaryFilter.")]),e._v(" "),s("p",[e._v('We give some examples of AndFilter and OrFilter, where "&&" indicates relation AND and "||" indicates relation OR.')]),e._v(" "),s("ol",[s("li",[e._v('AndFilter(TimeGt(100), TimeLt(200)) means "timestamp > 100 && timestamp < 200"')]),e._v(" "),s("li",[e._v('AndFilter (TimeGt(100), ValueGt(0.5)) means "timestamp > 100 && value > 0.5"')]),e._v(" "),s("li",[e._v('AndFilter (AndFilter (TimeGt(100), TimeLt(200)), ValueGt(0.5)) means "(timestamp > 100 && timestamp < 200) && value > 0.5"')]),e._v(" "),s("li",[e._v('OrFilter(TimeGt(100), ValueGt(0.5)) means "timestamp > 100 || value > 0.5"')]),e._v(" "),s("li",[e._v('OrFilter (AndFilter(TimeGt(100), TimeLt(200)), ValueGt(0.5)) means "(timestamp > 100 && timestamp < 200) || value > 0.5"')])]),e._v(" "),s("p",[e._v('The formal definition of "Filter", "AndFilter" and "OrFilter" are shown below:')]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("Filter := Basic Filter | AndFilter | OrFilter\nAndFilter := Filter && Filter\nOrFilter := Filter && Filter\n")])])]),s("p",[e._v("For simplicity, we symbolize Basic Filter, AndFilter and OrFilter. Note that t is a variable of type INT64, v is a variable whose type can be BOOLEAN, INT32, INT64, FLOAT, DOUBLE or BINARY。")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Name")]),e._v(" "),s("th",[e._v("symbol")]),e._v(" "),s("th",[e._v("Examples")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("TimeEq")]),e._v(" "),s("td",[e._v("time == t")]),e._v(" "),s("td",[e._v("time == 14152176545 means timestamp should be equal to 14152176545")])]),e._v(" "),s("tr",[s("td",[e._v("TimeGt")]),e._v(" "),s("td",[e._v("time > t")]),e._v(" "),s("td",[e._v("time > 14152176545 means timestamp should be greater than 14152176545")])]),e._v(" "),s("tr",[s("td",[e._v("TimeGtEq")]),e._v(" "),s("td",[e._v("time >= t")]),e._v(" "),s("td",[e._v("time >= 14152176545 means timestamp should be greater than or equal to 14152176545")])]),e._v(" "),s("tr",[s("td",[e._v("TimeLt")]),e._v(" "),s("td",[e._v("time < t")]),e._v(" "),s("td",[e._v("time < 14152176545 means timestamp should be less than 14152176545")])]),e._v(" "),s("tr",[s("td",[e._v("TimeLtEq")]),e._v(" "),s("td",[e._v("time <= t")]),e._v(" "),s("td",[e._v("time <= 14152176545 means timestamp should be less than or equal to 14152176545")])]),e._v(" "),s("tr",[s("td",[e._v("TimeNotEq")]),e._v(" "),s("td",[e._v("time != t")]),e._v(" "),s("td",[e._v("time != 14152176545 means timestamp")])])])]),e._v(" "),s("p",[e._v('should be equal to 14152176545\nValueEq| value == v| value == 10 means value should be equal to 10\nValueGt| value > v| value > 100.5 means value should be greater than 100.5\nValueGtEq| value >= v| value >= 2 means value should be greater than or equal to 2\nValueLt| value < v| value < "string" means value should be less than "string" in alphabet order\nValueLtEq| value <= v| value <= -100 means value should be less than or equal to -100\nValueNotEq| value != v| value != true means value should not be true\nAndFilter| <Filter> && <Filter>| 1. value > 100 && value < 200 means value should be greanter than 100 and less than 200; '),s("br"),e._v('2. (value >= 100 && value <= 200) && time > 14152176545 means "value should be greater than or equal to 100 and value should be less than or equal to" and "timestamp should be greater than 14152176545"\nOrFilter| <Filter> || <Filter>| 1. value > 100 || time >  14152176545, means value should be greater than 100 or timestamp should be greater than 14152176545;'),s("br"),e._v('2. (value > 100 && value < 200)|| time > 14152176545, means "value should be greater than 100 and value should be less than 200" or "timestamp should be greater than 14152176545"')]),e._v(" "),s("h3",{attrs:{id:"_1-2-expression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-expression"}},[e._v("#")]),e._v(" 1.2 Expression")]),e._v(" "),s("p",[e._v('When we assign a particular time series (including the timestamp) to a Filter, it becomes an expression. For example, "value > 10" can only describe a Filter, without the taste of a query. However, "the value of time series \'d1.s1\' should be greater than 10" is an expression. Specifically, if the Filter only works on timestamp, it can be seen as an expression, which is called GlobalTimeExpression. The following sections introduces Expression in detail,')]),e._v(" "),s("h4",{attrs:{id:"_1-2-1-singleseriesexpression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-singleseriesexpression"}},[e._v("#")]),e._v(" 1.2.1 SingleSeriesExpression")]),e._v(" "),s("p",[e._v("SingleSeriesExpression is an expression on a time series (excluding the timestamp column) with a Filter. A SingleSeriesExpression contains a Path and a Filter. The Path is the path of the time series, and the Filter indicate the filter condition, as is introduced in section 1.1.")]),e._v(" "),s("p",[e._v("The structure of SingleSeriesExpression is shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("SingleSeriesExpression\n    Path: the path of the time series in the given SingleSeriesExpression\n    Filter: filter condition\n")])])]),s("p",[e._v("When querying, a SingleSeriesExpression claims that the data point in the time series should satisfy the constraints in the Filter.")]),e._v(" "),s("p",[e._v("Examples of SingleSeriesExpression are shown below.")]),e._v(" "),s("p",[e._v("Example 1.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('SingleSeriesExpression\n    Path: "d1.s1"\n    Filter: AndFilter(ValueGt(100), ValueLt(200))\n')])])]),s("p",[e._v('The SingleSeriesExpression claims that time series "d1.s1" should satisfy that "value should be greater than 100 and less than 200"。')]),e._v(" "),s("p",[e._v('We formalize the rule as SingleSeriesExpression("d1.s1", value > 100 && value < 200)')]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Example 2.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('SingleSeriesExpression\n    Path: "d1.s1"\n    Filter: AndFilter(AndFilter(ValueGt(100), ValueLt(200)), TimeGt(14152176545))\n')])])]),s("p",[e._v('The SingleSeriesExpression claims that time series "d1.s1" should satisfy that "value should be greater than 100 and less than 200 and timestamp should be greater than 14152176545"。')]),e._v(" "),s("p",[e._v('We formalize the rule as SingleSeriesExpression("d1.s1", (value > 100 && value < 200) && time > 14152176545)')]),e._v(" "),s("h4",{attrs:{id:"_1-2-2-globaltimeexpression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-globaltimeexpression"}},[e._v("#")]),e._v(" 1.2.2 GlobalTimeExpression")]),e._v(" "),s("p",[e._v("GlobalTimeExpression means a global time filter. A GlobalTimeExpression contains a Filter, which is only composed of time filters (value filters not allowed). When querying, a GlobalTimeExpression claims that data points of all selected time series should satisfy the constraints in the Filter. The structure of GlobalTimeExpression is shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("GlobalTimeExpression\n    Filter: a filter which only contains time filters。\n    The formalized definition of Filter here is: \n        Filter := TimeFilter | AndExpression | OrExpression\n        AndExpression := Filter && Filter\n        OrExpression := Filter && Filter\n")])])]),s("p",[e._v("Some formalized examples of GlobalTimeExpression are shown below:")]),e._v(" "),s("ol",[s("li",[e._v('GlobalTimeExpression(time > 14152176545 && time < 14152176645) claims that the all selected time series should satisfy that the timestamp should be "greater than 14152176545 and less than 14152176645"')]),e._v(" "),s("li",[e._v('GlobalTimeExpression((time > 100 && time < 200) || (time > 400 && time < 500)) claims that all selected time series should satisfy that the timestamp should be "greater than 100 and less than 200" or "greater than 400 and less than 500"')])]),e._v(" "),s("h4",{attrs:{id:"_1-2-3-iexpression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-iexpression"}},[e._v("#")]),e._v(" 1.2.3 IExpression")]),e._v(" "),s("p",[e._v("IExpression indicates the all filters with the corresponding columns in a query.\nAn IExpression can be a SingleSeriesExpression or a GlobalTimeExpression. In this case, the IExpression is a UnaryExpression. An IExpression can also contains two IExpressions, connected with relation AND or OR. Two IExpressions joined with AND relation is termed as AndExpression. Likewise, two IExpressions joined with OR relation is termed as OrExpression. An IExpression containing two children is termed BinaryExpression. UnaryExpression and BinaryExpression are both IExpression.")]),e._v(" "),s("p",[e._v("The formalized definition of IExpression is shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("IExpression := SingleSeriesExpression | GlobalTimeExpression | AndExpression | OrExpression\nAndExpression := IExpression && IExpression\nOrExpression := IExpression || IExpression\n")])])]),s("p",[e._v("We use a tree-like structure to formalize an IExpression. Here are some examples.")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("An IExpression only contains a SingleSeriesExpression:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v(' IExpression(SingleSeriesExpression("d1.s1", value > 100 && value < 200))\n')])])])]),e._v(" "),s("li",[s("p",[e._v("An IExpression only contains a GlobalTimeExpression:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v(" IExpression(GlobalTimeExpression (time > 14152176545 && time < 14152176645))\n")])])])]),e._v(" "),s("li",[s("p",[e._v("An IExpression contains multiple SingleSeriesExpressions:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v(' IExpression(\n     AndExpression\n         SingleSeriesExpression("d1.s1", (value > 100 && value < 200) || time > 14152176645)\n         SingleSeriesExpression("d1.s2", value > 0.5 && value < 1.5)\n )\n')])])]),s("p",[s("strong",[e._v("Note")]),e._v(': The IExpression is an AndExpression, where the time series "d1.s1" and "d1.s2" should satisfy the constraints in the Filter.')])]),e._v(" "),s("li",[s("p",[e._v("An IExpression contains both SingleSeriesExpressions and GlobalTimeExpressions")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v(' IExpression(\n     AndExpression\n         AndExpression\n             SingleSeriesExpression("d1.s1", (value > 100 && value < 200) || time > 14152176645)\n             SingleSeriesExpression("d1.s2", value > 0.5 && value < 1.5)\n         GlobalTimeExpression(time > 14152176545 && time < 14152176645)\n )\n')])])]),s("p",[s("strong",[e._v("Note")]),e._v(': The IExpression is an AndExpression, where the time series "d1.s1" and "d1.s2" should not only satisfy the constraints in corresponding Filters in SingleSeriesExpression, but also the constraints of the GlobalTimeExpression.')])])]),e._v(" "),s("h4",{attrs:{id:"_1-2-4-executable-expression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-executable-expression"}},[e._v("#")]),e._v(" 1.2.4 Executable Expression")]),e._v(" "),s("p",[e._v("To make the query execution more comprehensible, we give the concept of executable expression. An executable expression is a particular kinds of IExpression. The IExpression customized by system user can be transformed to an executable expression by some algorithm, which will be introduced in the following sections. An executable expression is an IExpression satisfying one of the following constraints:")]),e._v(" "),s("ol",[s("li",[e._v("The IExpression is a single GlobalTimeExpression")]),e._v(" "),s("li",[e._v("The IExpression is a single SingleSeriesExpression")]),e._v(" "),s("li",[e._v("The IExpression is an AndExpression, whose leaf nodes are SingleSeriesExpressions")]),e._v(" "),s("li",[e._v("The IExpression is an OrExpression, whose leaf nodes are SingleSeriesExpressions")])]),e._v(" "),s("p",[e._v("The formalized definition of an executable expression is shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("executable expression := SingleSeriesExpression| GlobalTimeExpression | AndExpression | OrExpression\nAndExpression := < ExpressionUNIT > && < ExpressionUNIT >\nOrExpression := < ExpressionUNIT > || < ExpressionUNIT >\nExpressionUNIT := SingleSeriesExpression | AndExpression | OrExpression\n")])])]),s("p",[e._v("Some examples of executable expression and non-executable expression are show below:")]),e._v(" "),s("p",[e._v("Example 1:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('IExpression(SingleSeriesExpression("d1.s1", value > 100 && value < 200))\n')])])]),s("p",[e._v("Is an executable expression? Yes")]),e._v(" "),s("p",[s("strong",[e._v("Hint")]),e._v(": The IExpression is a single SingleSeriesExpression, satisfying constraint 1")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Example 2:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("IExpression(GlobalTimeExpression (time > 14152176545 && time < 14152176645))\n")])])]),s("p",[e._v("Is an executable expression? Yes")]),e._v(" "),s("p",[s("strong",[e._v("Hint")]),e._v(": The IExpression is a single GlobalTimeExpression, satisfying constraint 2")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Example 3:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("IExpression(\n    AndExpression\n        GlobalTimeExpression (time > 14152176545)\n        GlobalTimeExpression (time < 14152176645)\n)\n")])])]),s("p",[e._v("Is an executable expression? No")]),e._v(" "),s("p",[s("strong",[e._v("Hint")]),e._v(": The IExpression is an AndExpression, but it contains GlobalTimeExpressions, which is against constraint 3")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Example 4:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('IExpression(\n    OrExpression\n        AndExpression\n            SingleSeriesExpression("d1.s1", (value > 100 && value < 200) || time > 14152176645)\n            SingleSeriesExpression("d1.s2", value > 0.5 && value < 1.5)\n    SingleSeriesExpression("d1.s3", value > "test" && value < "test100")\n)\n')])])]),s("p",[e._v("Is an executable expression? Yes")]),e._v(" "),s("p",[s("strong",[e._v("Hint")]),e._v(": The IExpression is an OrExpression, whose leaf nodes are all SingleSeriesExpressions, which satisfies constraints 4.")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("Example 5:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('IExpression(\n    AndExpression        \n        AndExpression\n            SingleSeriesExpression("d1.s1", (value > 100 && value < 200) || time > 14152176645)\n            SingleSeriesExpression("d1.s2", value > 0.5 && value < 1.5)\n        GlobalTimeExpression(time > 14152176545 && time < 14152176645)\n)\n')])])]),s("p",[e._v("Is an executable expression? No")]),e._v(" "),s("p",[s("strong",[e._v("Hint")]),e._v(": The IExpression is an AndExpression, but one of the leaf nodes is a GlobalTimeExpression, which is against constraint 3.")]),e._v(" "),s("h4",{attrs:{id:"_1-2-5-the-algorithm-transforming-iexpression-to-an-executable-expression"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-the-algorithm-transforming-iexpression-to-an-executable-expression"}},[e._v("#")]),e._v(" 1.2.5 The Algorithm Transforming IExpression to an Executable Expression")]),e._v(" "),s("p",[e._v("In this section, we introduce how to transform an IExpression to be executable.")]),e._v(" "),s("p",[e._v("If an IExpression is not executable, it is either an AndExpression, or an OrExpression. Moreover, it contains both GlobalTimeExpressions and SingleSeriesExpressions. According to the definition in the preceding sections, an AndExpression or OrExpression is composed of two IExpressions, that")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("AndExpression := <IExpression> AND <IExpression>\nOrExpression := <IExpression> OR <IExpression>\n")])])]),s("p",[e._v("We denote the left child and right child as LeftIExpression and RightIExpression, so that")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("AndExpression := <LeftIExpression> AND <RightIExpression>\nOrExpression := <LeftIExpression> OR <RightIExpression>\n")])])]),s("p",[e._v("The declaration of the method is shown below.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("IExpression optimize (IExpression expression, List<Path> selectedSeries)\n\nInput: The IExpression to be transformed, and the projected time series\nOutput: The transformed IExpression, which is executable\n")])])]),s("p",[e._v("Before the introducing the optimize() method in detail, we first show how to combine two expressions or filters, which is very useful in the optimize() method.")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("combineTwoGlobalTimeExpression combines two GlobalTimeExpressions to be a single GlobalTimeExpression。")]),e._v(" "),s("p",[e._v("This method receives three inputs. The declaration of the method is:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('  GlobalTimeExpression combineTwoGlobalTimeExpression(\n      GlobalTimeExpression leftGlobalTimeExpression,\n      GlobalTimeExpression rightGlobalTimeExpression,\n      ExpressionType type)\n\n  Input 1: leftGlobalTimeExpression\n  Input 2: rightGlobalTimeExpression\n  Input 3: type, the relation of the two expressions, which is either "AND" or "OR"\n\n  Output: GlobalTimeExpression, which is the merged expression\n')])])]),s("p",[e._v("The method contains two steps:")]),e._v(" "),s("ol",[s("li",[e._v("Denote the Filter in leftGlobalTimeExpression as filter1, in rightGlobalTimeExpression as filter2. It first merges filter1 and filter2 to be a new Filter, denoted as filter3. The method of merging two filters is shown in MergeFilter in the following section.")]),e._v(" "),s("li",[e._v("Generate a new GlobalTimeExpression, and assign filter3 to be its Filter. This new GlobalTimeExpression is the result.")])]),e._v(" "),s("p",[e._v("An example of combining two GlobalTimeExpressions is shown below.")]),e._v(" "),s("p",[e._v("The three inputs are:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  leftGlobalTimeExpression: GlobalTimeExpression(Filter: time > 100 && time < 200)\n  rightGlobalTimeExpression: GlobalTimeExpression(Filter: time > 300 && time < 400)\n  type: OR\n")])])]),s("p",[e._v("than, the merged expression is")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  GlobalTimeExpression(Filter: (time > 100 && time < 200) || (time > 300 && time < 400))\n")])])])]),e._v(" "),s("li",[s("p",[e._v("MergeFilter merges two Filters. This method receives three inputs:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  Filter1: The first Filter to merge\n  Filter2: The second Filter to merge\n  Relation: The relation between the two Filters (either AND or OR)\n")])])]),s("p",[e._v("than, the execution strategy of this method is")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  if relation == AND:\n      return AndFilter(Filter1, Filter2)\n  else if relation == OR:\n      return OrFilter(Filter1, Filter2)\n")])])]),s("p",[e._v("This method is implemented in "),s("code",[e._v("AndFilter and(Filter left, Filter right)")]),e._v(" and "),s("code",[e._v("OrFilter or(Filter left, Filter right)")]),e._v(" in class FilterFactory.")])]),e._v(" "),s("li",[s("p",[e._v("handleOneGlobalExpression merges a GlobalTimeExpression and an IExpression to be one executable expression. The result of the method only contains SingleSeriesExpressions. The declaration of the function is shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  IExpression handleOneGlobalTimeExpression(\n      GlobalTimeExpression globalTimeExpression,\n      IExpression expression,\n      List<Path> selectedSeries, \n      ExpressionType relation)\n\n  Input 1: GlobalTimeExpression\n  Input 2: IExpression\n  Input 3: time series to project\n  Input 4: the relation between the two expressions (either AND or OR)\n\n  Output: an IExpression which is executable\n")])])]),s("p",[e._v("This method first calls optimize() to transform the second input IExpression to be executable, which is recursive in view of optimize(), and then combine them in two ways.")]),e._v(" "),s("p",[s("em",[e._v("Case 1")]),e._v(": The relation between GlobalTimeExpression and the optimized IExpression is AND. In this case, denote the Filter in GlobalTimeExpression as Filter. We just need to merge the tFilter to the Filters of each SingleSeriesExpression in the IExpression。This method is implemented in "),s("code",[e._v("void addTimeFilterToQueryFilter(Filter timeFilter, IExpression expression)")]),e._v(". Here is an example:")]),e._v(" "),s("p",[e._v("To combine the following GlobaLTimeFilter and IExpression where")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('  1. GlobaLTimeFilter(tFilter)\n  2. IExpression\n          AndExpression\n              OrExpression\n                  SingleSeriesExpression("path1", filter1)\n                  SingleSeriesExpression("path2", filter2)\n              SingleSeriesExpression("path3", filter3)\n')])])]),s("p",[e._v("The result is")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('  IExpression\n      AndExpression\n          OrExpression\n              SingleSeriesExpression("path1", AndFilter(filter1, tFilter))\n              SingleSeriesExpression("path2", AndFilter(filter2, tFilter))\n          SingleSeriesExpression("path3", AndFilter(filter3, tFilter))\n')])])]),s("p",[s("em",[e._v("Case 2")]),e._v(": The relation between GlobalTimeExpression and IExpression is OR. In this case, the merge steps include:")]),e._v(" "),s("ol",[s("li",[e._v("Analyse the projected time series, which is a set of Path. To take a query with 3 projected time series as an example, denote that projected time series as a set, PathList{path1, path2, path3}。")]),e._v(" "),s("li",[e._v("Denote the Filter in GlobalTimeExpression to be tFilter. The method calls pushGlobalTimeFilterToAllSeries() to generate a corresponding SingleSeriesExpression for each Path. Set the Filters of SingleSeriesExpressions to be tFilter. Join the generated SingleSeriesExpression with OR operator to get an OrExpression, which is denoted as orExpression.")]),e._v(" "),s("li",[e._v("Call mergeSecondTreeToFirstTree method to combine the nodes in IExpression with the nodes in the orExpression, which is generated from step 2. The combined structure is the result expression.")])]),e._v(" "),s("p",[e._v("For example, to combine the following GlobalTimeFilter and IExpression using OR relation, denote the projected time series as PathList{path1, path2, path3}")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('  1. GlobalTimeFilter(tFilter)\n  2. IExpression\n          AndExpression\n              SingleSeriesExpression("path1", filter1)\n              SingleSeriesExpression("path2", filter2)\n')])])]),s("p",[e._v("the result is")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('  IExpression\n      OrExpression\n          AndExpression\n              SingleSeriesExpression("path1", filter1)\n              SingleSeriesExpression("path2", filter2)\n          OrExpression\n              OrExpression\n                  SingleSeriesExpression("path1", tFilter)\n                  SingleSeriesExpression("path2", tFilter)\n              SingleSeriesExpression("path3", tFilter)\n')])])])]),e._v(" "),s("li",[s("p",[e._v("MergeIExpression combines two IExpressions to be one executable expression. This method receives three inputs, respectively")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  IExpression1: the first IExpression to merge\n  IExpression2: the second IExpression to merge\n  relation: the relation between the two IExpressions (AND or OR)\n")])])]),s("p",[e._v("The strategy of the method is:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  if relation == AND:\n      return AndExpression(IExpression1, IExpression2)\n  else if relation == OR:\n      return OrExpression(IExpression1, IExpression2)\n")])])])])]),e._v(" "),s("p",[e._v("Using the above four combination methods, the steps of optimize() include:")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("If the IExpression is a UnaryExpression, (a single SingleSeriesExpression or GlobalTimeExpression), return the IExpression without any operations. Otherwise, go to step 2.")])]),e._v(" "),s("li",[s("p",[e._v("When it reaches this step, it means that the IExpression is an AndExpression or OrExpression.")]),e._v(" "),s("p",[e._v("a. If the LeftIExpression and RightIExpression both are GlobalTimeExpression, use combineTwoGlobalTimeExpression method, and output the result.")]),e._v(" "),s("p",[e._v("b. If LeftIExpression is a GlobalTimeExpression, and RightIExpression is not a GlobalTimeExpression, call handleOneGlobalExpression() to combine them。")]),e._v(" "),s("p",[e._v("c. If LeftIExpression is not a GlobalTimeExpression, while RightIExpression is, call handleOneGlobalExpression() to combine them.")]),e._v(" "),s("p",[e._v("d. If neither LeftIExpression nor RightIExpression is a GlobalTimeExpression, recursively call optimize() method on both LeftIExpression  and RightIExpression to get the left executable expression and the right executable expression. Then use mergeIExpression method to generate a final IExpression which is executable.")])])]),e._v(" "),s("h2",{attrs:{id:"_2-query-execution-of-tsfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-query-execution-of-tsfile"}},[e._v("#")]),e._v(" 2 Query Execution of TsFile")]),e._v(" "),s("h3",{attrs:{id:"_2-1-design"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-design"}},[e._v("#")]),e._v(" 2.1 Design")]),e._v(" "),s("p",[e._v("The interface of TsFile on file level is intended only for queries on original data. According to the existence of value filter, the query can be divided into two groups: those without filters or only with a time filter, and those containing value filters.")]),e._v(" "),s("p",[e._v("To execute the two kinds of queries, we design two query execution methods:")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("merge query")]),e._v(" "),s("p",[e._v("It generates multiple readers, aligns the result in time, and returns the result set.")])]),e._v(" "),s("li",[s("p",[e._v("join query")]),e._v(" "),s("p",[e._v("According to the query conditions, it generates satisfying timestamp, which is used for generating result set.")])])]),e._v(" "),s("h3",{attrs:{id:"_2-2-three-components"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-three-components"}},[e._v("#")]),e._v(" 2.2 Three Components")]),e._v(" "),s("h4",{attrs:{id:"_2-2-1-fileseriesreader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-fileseriesreader"}},[e._v("#")]),e._v(" 2.2.1 FileSeriesReader")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.reader.series.FileSeriesReader")]),e._v(" "),s("p",[s("strong",[e._v("Functions")]),e._v(": FileSeriesReader queries the data points of a time series in a file, which satisfies the filter conditions. It outputs the data points of the given time series in the given file in timestamp ascending order. There can be no filters at all.")]),e._v(" "),s("p",[s("strong",[e._v("Implementation")]),e._v(": FileSeriesReader retrieves the Chunk information of the given time series according to the Path, it then traverses each Chunk in timestamp ascending order, and outputs the satisfying data points.")]),e._v(" "),s("h4",{attrs:{id:"_2-2-2-fileseriesreaderbytimestamp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-fileseriesreaderbytimestamp"}},[e._v("#")]),e._v(" 2.2.2 FileSeriesReaderByTimestamp")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.reader.series.FileSeriesReaderByTimestamp")]),e._v(" "),s("p",[s("strong",[e._v("Functions")]),e._v(": FileSeriesReaderByTimestamp queries the data points of a time series in a file, whose timestamp satisfies the timestamp constraints.")]),e._v(" "),s("p",[s("strong",[e._v("Implementation")]),e._v(": This component provides an interface, getValueInTimestamp(long timestamp), which receives increasing timestamp value,  and outputs the data points on the time series whose timestamp is identical. If there's no such data point, the result is null.")]),e._v(" "),s("h4",{attrs:{id:"_2-2-3-tsfiletimegenerator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-tsfiletimegenerator"}},[e._v("#")]),e._v(" 2.2.3 TsFileTimeGenerator")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.query.timegenerator.TsFileTimeGenerator")]),e._v(" "),s("p",[s("strong",[e._v("Functions")]),e._v(": According to the filter condition, TimeGeneratorImpl generates the satisfying timestamp. It first transforms the filter conditions to be a binary tree, and recursively generate the satisfying timestamp. This component is used in executing join query.")]),e._v(" "),s("p",[e._v("An executable expression contains one or nultiple SingleSeriesExpressions. The relation between two SingleSeriesExpressions is either AND or OR. Therefore, the filter in an executable expression can be transformed to a binary tree, where the leaf nodes are FileSeriesReader, and the non-leaf nodes are AndNode or OrNode. Particularly, when the expression only contains a single SingleSeriesExpression, the binary tree only has one node. The satisfying timestamp can be generated using the binary tree.")]),e._v(" "),s("p",[e._v("This component provides two basic functions:")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("check if there exists a next satisfying timestamp")])]),e._v(" "),s("li",[s("p",[e._v("get the next satisfying timestamp")])])]),e._v(" "),s("h3",{attrs:{id:"_2-3-merge-query"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-merge-query"}},[e._v("#")]),e._v(" 2.3 Merge Query")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.query.dataset.DataSetWithoutTimeGenerator")]),e._v(" "),s("p",[e._v("Suppose there are n time series. For each one of them, a FileSeriesReader will be generated. If there's a GlobalTimeExpression, the filter in it will be input to the FileSeriesReaders.")]),e._v(" "),s("p",[e._v("A DataSetWithoutTimeGenerator will be generated using these FileSeriesReaders. Since each FileSeriesReader outputs data points in time stamp ascending order, we can use the idea of k-way merge to align the result data points.")]),e._v(" "),s("p",[e._v("The steps include:")]),e._v(" "),s("p",[e._v("(1) Create a min-heap, which stores timestamps. The min-heap is organized according to the value of the timestamp.")]),e._v(" "),s("p",[e._v("(2) Initialize the min-heap. Access each FileSeriesReader once. If there's a next data point in the FileSeriesReader, add its timestamp to the min-heap. Till now, the heap contains at most one timestamp of each time series, which is the minimum in its corresponding time series.")]),e._v(" "),s("p",[e._v("(3) If the size of the heap is greater than 0, take the timestamp on the top of the heap, denote it as t, and remove it from the heap, then go to step (4). If the number of the heap is 0, go to step (5).")]),e._v(" "),s("p",[e._v("(4) Create a new RowRecord. In turns access each time series. When dealing with a time series, first check if there's a next data point, if it fails, set the result data point to be null. Otherwise, check if minimum timestamp in the time series is identical to t. If it is not, set the result data point to be null. Otherwise, get the data point and set it to be the result data point. If there exists a next data point after that. If it has, then set timestamp of the next data point in the time series to be its minimum timestamp. After accessing all time series, combine the result data points to form a RowRecord. Finally, go to step (3).")]),e._v(" "),s("p",[e._v("(5) Terminate the process.")]),e._v(" "),s("h3",{attrs:{id:"_2-4-join-query"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-join-query"}},[e._v("#")]),e._v(" 2.4 Join Query")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.query.executor.ExecutorWithTimeGenerator")]),e._v(" "),s("p",[e._v("Join query execution generates timestamp according to the filter conditions, and retrieves the data point on the projected time series to form a RowRecord. Main steps include;")]),e._v(" "),s("p",[e._v("(1) According to QueryExpression, initialize the timestamp generation module, TimeGeneratorImpl")]),e._v(" "),s("p",[e._v("(2) Generate FileSeriesReaderByTimestamp for each projected time series.")]),e._v(" "),s("p",[e._v('(3) If there exists a next timestamp in the "timestamp generation module", denote the timestamp t, go to step (4).Otherwise, terminate the query execution.')]),e._v(" "),s("p",[e._v("(4) According to t, utilize FileSeriesReaderByTimestamp on each time series to retrieve the data point whose corresponding timestamp is t. If there's no such data point, use null to represent it.")]),e._v(" "),s("p",[e._v("(5) Combine the data points in step (4) to form a RowRecord, then go to step (3) to generate another row of records.")]),e._v(" "),s("h3",{attrs:{id:"_2-5-query-of-tsfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-query-of-tsfile"}},[e._v("#")]),e._v(" 2.5 Query of TsFile")]),e._v(" "),s("p",[e._v("org.apache.iotdb.tsfile.read.query.executor.TsFileExecutor")]),e._v(" "),s("p",[e._v("TsFileExecutor receives a QueryExpression, execute the query and outputs the QueryDataSet。The work flow includes the following steps:")]),e._v(" "),s("p",[e._v("(1) Receive a QueryExpression.")]),e._v(" "),s("p",[e._v("(2) If the QueryExpression contains no filter conditions, execute merge query. If it contains any Filters, use ExpressionOptimizer to optimize the IExpression in QueryExpression. If the optimized IExpression is a GlobalTimeExpression, execute merge query. If it contains value filters, it sends a message to ExecutorWithTimeGenerator to execute join query.")]),e._v(" "),s("p",[e._v("(3) Generate the QueryDataSet. It iteratively generates RowRecord and returns the results.")]),e._v(" "),s("h3",{attrs:{id:"_2-6-related-concepts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-related-concepts"}},[e._v("#")]),e._v(" 2.6 Related Concepts")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("Chunk: Chunk is the storage structure of a chunk of time series. IChunkReader is for reading the content。")])]),e._v(" "),s("li",[s("p",[e._v("ChunkMetaData: ChunkMetaData records the offset, data type and encoding info of the Chunk in the File.")])]),e._v(" "),s("li",[s("p",[e._v("IMetadataQuerier: IMetadataQuerier is a querier for TsFile metadata. It queries the metadata of a file, and the ChunkMetaData of a time series.")])]),e._v(" "),s("li",[s("p",[e._v("IChunkLoader:  IChunkLoader is the loader for Chunk, whose main function is getting the corresponding Chunk of the given the ChunkMetaData.")])]),e._v(" "),s("li",[s("p",[e._v("IChunkReader: IChunkReader reads the data in a Chunk. It receives a Chunk and parse it according to the info in the ChunkHeader. It provides two interface:")]),e._v(" "),s("ul",[s("li",[e._v("hasNextSatisfiedPage & nextPageData: iteratively returns a Page")]),e._v(" "),s("li",[e._v("getPageReaderList: return all PageReader")])])]),e._v(" "),s("li",[s("p",[e._v("IPageReader: IPageReader reads the data in a Page. It provides two interface:")]),e._v(" "),s("ul",[s("li",[e._v("getAllSatisfiedPageData(): return all satisfying values")]),e._v(" "),s("li",[e._v("getStatistics(): return the statistic information of the Page")])])]),e._v(" "),s("li",[s("p",[e._v("QueryExpression")]),e._v(" "),s("p",[e._v("QueryExpression is the query expression, which contains the time series to project, and filter constraints.")])]),e._v(" "),s("li",[s("p",[e._v("QueryDataSet")]),e._v(" "),s("p",[e._v("The result of a query. It contains one or multiple RowRecord, which combines data points having identical time stamp together. QueryDataSet provides two interface:")]),e._v(" "),s("ul",[s("li",[e._v("check if there's a next RowRecord.")]),e._v(" "),s("li",[e._v("return the next RowRecord.")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);