(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{763:function(t,s,a){"use strict";a.r(s);var n=a(80),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"按设备对齐查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#按设备对齐查询"}},[t._v("#")]),t._v(" 按设备对齐查询")]),t._v(" "),a("p",[t._v("AlignByDevicePlan 即按设备对齐查询对应的表结构为：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Time")]),t._v(" "),a("th",[t._v("Device")]),t._v(" "),a("th",[t._v("sensor1")]),t._v(" "),a("th",[t._v("sensor2")]),t._v(" "),a("th",[t._v("sensor3")]),t._v(" "),a("th",[t._v("...")])])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("h2",{attrs:{id:"设计原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计原理"}},[t._v("#")]),t._v(" 设计原理")]),t._v(" "),a("p",[t._v("按设备对齐查询其实现原理主要是计算出查询中每个设备对应的测点和过滤条件，然后将查询按设备分别进行，最后将结果集拼装并返回。")]),t._v(" "),a("h3",{attrs:{id:"alignbydeviceplan-中重要字段含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alignbydeviceplan-中重要字段含义"}},[t._v("#")]),t._v(" AlignByDevicePlan 中重要字段含义")]),t._v(" "),a("p",[t._v("首先解释一下 AlignByDevicePlan 中一些重要字段的含义：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("List<String> measurements")]),t._v("：查询中出现的 measurement 列表。")]),t._v(" "),a("li",[a("code",[t._v("List<String> devices")]),t._v(": 由前缀路径得到的设备列表。")]),t._v(" "),a("li",[a("code",[t._v("Map<String, IExpression> deviceToFilterMap")]),t._v(": 用来存储设备对应的过滤条件。")]),t._v(" "),a("li",[a("code",[t._v("Map<String, TSDataType> measurementDataTypeMap")]),t._v("：该字段用于记录时间序列的实际数据类型，用于实际查询，其键值不包含聚合函数。")]),t._v(" "),a("li",[a("code",[t._v("Map<String, TSDataType> columnDataTypeMap")]),t._v("：该字段用来记录结果集中每列的数据类型，用于构造表头，输出结果集，可含有聚合函数。")]),t._v(" "),a("li",[a("code",[t._v("enum MeasurementType")]),t._v("：记录 measurement 类型。在任何设备中都不存在的 measurement 为 "),a("code",[t._v("NonExist")]),t._v(" 类型；存在的 measurement 为 "),a("code",[t._v("Exist")]),t._v(" 类型。")]),t._v(" "),a("li",[a("code",[t._v("Map<String, MeasurementType> measurementTypeMap")]),t._v(": 该字段用来记录查询中所有 measurement 的类型。")]),t._v(" "),a("li",[t._v("groupByTimePlan, fillQueryPlan, aggregationPlan：为了避免冗余，这三个执行计划被设定为 RawDataQueryPlan 的子类，而在 AlignByDevicePlan 中被设置为变量。如果查询计划属于这三个计划中的一种，则该字段会被赋值并保存。")])]),t._v(" "),a("p",[t._v("在进行具体实现过程的讲解前，先给出一个覆盖较为完整的例子，下面的解释过程中将结合该示例进行说明。")]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" s1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s5 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("d1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" root"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("time")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" s1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("25")]),t._v(" ALIGN "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" DEVICE\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("其中，系统中的时间序列为：")]),t._v(" "),a("ul",[a("li",[t._v("root.sg.d1.s1")]),t._v(" "),a("li",[t._v("root.sg.d1.s2")]),t._v(" "),a("li",[t._v("root.sg.d2.s1")])]),t._v(" "),a("p",[t._v("存储组 "),a("code",[t._v("root.sg")]),t._v(" 共包含两个设备 d1 和 d2，其中 d1 有两个传感器 s1 和 s2，d2 只有传感器 s1，相同传感器 s1 的数据类型相同。")]),t._v(" "),a("p",[t._v("下面将按具体过程进行分别解释：")]),t._v(" "),a("h3",{attrs:{id:"逻辑计划生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逻辑计划生成"}},[t._v("#")]),t._v(" 逻辑计划生成")]),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.qp.Planner")])]),t._v(" "),a("p",[t._v("与原始数据查询不同，按设备对齐查询并不在此阶段进行 SELECT 语句和 WHERE 语句中后缀路径的拼接，而将在后续生成物理计划时，计算出每个设备对应的映射值和过滤条件。")]),t._v(" "),a("p",[t._v("因此，按设备对齐在此阶段所做的工作只包括对 WHERE 语句中过滤条件的优化。")]),t._v(" "),a("p",[t._v("对过滤条件的优化主要包括三部分：去非、转化析取范式、合并同路径过滤条件。对应的优化器分别为：RemoveNotOptimizer, DnfFilterOptimizer, MergeSingleFilterOptimizer。该部分逻辑可参考："),a("RouterLink",{attrs:{to:"/zh/SystemDesign/QueryEngine/Planner.html"}},[t._v("Planner")]),t._v(".")],1),t._v(" "),a("h3",{attrs:{id:"物理计划生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#物理计划生成"}},[t._v("#")]),t._v(" 物理计划生成")]),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.qp.strategy.PhysicalGenerator")])]),t._v(" "),a("p",[t._v("生成逻辑计划后，将调用 PhysicalGenerator 类中的 "),a("code",[t._v("transformToPhysicalPlan()")]),t._v(" 方法将该逻辑计划转化为物理计划。对于按设备对齐查询，该方法的主要逻辑实现在 "),a("code",[t._v("transformQuery()")]),t._v(" 方法中。")]),t._v(" "),a("p",[a("strong",[t._v("该阶段所做的主要工作为生成查询对应的")]),t._v(" "),a("code",[t._v("AlignByDevicePlan")]),t._v("，"),a("strong",[t._v("填充其中的变量信息。")])]),t._v(" "),a("p",[t._v("其主要将 SELECT 语句中得到的后缀路径与 FROM 子句中的前缀路径进行拼接，从而计算出查询的 Measurement 及其类型、数据类型，计算流程如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 首先遍历后缀路径")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" suffixPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),t._v(" suffixPath "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" suffixPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于记录此后缀路径对应的所有 measurement，示例见下文")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" measurementSetOfGivenSuffix "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedHashSet")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 后缀路径不为常量，则将其与各个设备拼接得到完整路径")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" device "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" devices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),t._v(" fullPath "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addPrefixPath")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("suffixPath"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" device"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设备列表中已经去除通配符，但是后缀路径仍可能含有通配符")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 去除通配符后得到实际的时间序列路径")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" actualPaths "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMatchedTimeseries")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fullPath"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getFullPath")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果拼接后的路径不存在，则暂时识别为 `NonExist`")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 后续如果出现设备存在该 measurement，则覆盖 `NonExist` 值为 `Exist`")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("actualPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" originAggregations"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 分别取得带聚合函数和不带聚合函数（实际时间序列）的数据类型")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 带聚合函数的数据类型 `columnDataTypes` 用于 1. 数据类型一致性检查 2. 表头计算，输出结果集")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 时间序列的实际数据类型 `measurementDataTypes` 则用于 AlignByDeviceDataSet 中的实际查询")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" aggregation "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n            originAggregations "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("originAggregations"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" originAggregations"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Pair")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TSDataType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TSDataType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" pair "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSeriesTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("actualPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            aggregation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TSDataType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" columnDataTypes "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pair"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TSDataType")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" measurementDataTypes "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pair"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pathIdx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" pathIdx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" actualPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" pathIdx"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),t._v(" path "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("actualPaths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pathIdx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查同名传感器的数据类型一致性")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TSDataType")]),t._v(" columnDataType "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" columnDataTypes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pathIdx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果有同名传感器则进行数据类型比较")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("columnDataTypeMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("containsKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数据类型不一致则抛出异常，结束")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("columnDataType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("columnDataTypeMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n              "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("QueryProcessException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前没有该 Measurement 则进行记录")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进行到这一步说明该 Measurement 在该设备下存在且正确，")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 首先更新 measurementSetOfGivenSuffix，重复则不可再加入")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 其次如果该 measurement 之前其被识别为 NonExist 类型，则将其更新为 Exist")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementSetOfGivenSuffix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n              "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" measurementTypeMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MeasurementType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Exist")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            measurementTypeMap"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("put")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementChecked"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MeasurementType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Exist")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新 paths")]),t._v("\n          paths"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MetadataException")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LogicalOptimizeException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新 measurements")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意在一个后缀路径的循环内部，使用了 set 避免重复的 measurement")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 而在循环外部使用了 List 来保证输出包含用户输入的所有 measurements")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 示例中，对于后缀 *, measurementSetOfGivenSuffix = {s1,s2}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对于后缀 s1, measurementSetOfGivenSuffix = {s1}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 因此最终 measurements 为 [s1,s2,s1].")]),t._v("\n    measurements"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("measurementSetOfGivenSuffix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br"),a("span",{staticClass:"line-number"},[t._v("27")]),a("br"),a("span",{staticClass:"line-number"},[t._v("28")]),a("br"),a("span",{staticClass:"line-number"},[t._v("29")]),a("br"),a("span",{staticClass:"line-number"},[t._v("30")]),a("br"),a("span",{staticClass:"line-number"},[t._v("31")]),a("br"),a("span",{staticClass:"line-number"},[t._v("32")]),a("br"),a("span",{staticClass:"line-number"},[t._v("33")]),a("br"),a("span",{staticClass:"line-number"},[t._v("34")]),a("br"),a("span",{staticClass:"line-number"},[t._v("35")]),a("br"),a("span",{staticClass:"line-number"},[t._v("36")]),a("br"),a("span",{staticClass:"line-number"},[t._v("37")]),a("br"),a("span",{staticClass:"line-number"},[t._v("38")]),a("br"),a("span",{staticClass:"line-number"},[t._v("39")]),a("br"),a("span",{staticClass:"line-number"},[t._v("40")]),a("br"),a("span",{staticClass:"line-number"},[t._v("41")]),a("br"),a("span",{staticClass:"line-number"},[t._v("42")]),a("br"),a("span",{staticClass:"line-number"},[t._v("43")]),a("br"),a("span",{staticClass:"line-number"},[t._v("44")]),a("br"),a("span",{staticClass:"line-number"},[t._v("45")]),a("br"),a("span",{staticClass:"line-number"},[t._v("46")]),a("br"),a("span",{staticClass:"line-number"},[t._v("47")]),a("br"),a("span",{staticClass:"line-number"},[t._v("48")]),a("br"),a("span",{staticClass:"line-number"},[t._v("49")]),a("br"),a("span",{staticClass:"line-number"},[t._v("50")]),a("br"),a("span",{staticClass:"line-number"},[t._v("51")]),a("br"),a("span",{staticClass:"line-number"},[t._v("52")]),a("br"),a("span",{staticClass:"line-number"},[t._v("53")]),a("br"),a("span",{staticClass:"line-number"},[t._v("54")]),a("br"),a("span",{staticClass:"line-number"},[t._v("55")]),a("br"),a("span",{staticClass:"line-number"},[t._v("56")]),a("br"),a("span",{staticClass:"line-number"},[t._v("57")]),a("br"),a("span",{staticClass:"line-number"},[t._v("58")]),a("br"),a("span",{staticClass:"line-number"},[t._v("59")]),a("br"),a("span",{staticClass:"line-number"},[t._v("60")]),a("br"),a("span",{staticClass:"line-number"},[t._v("61")]),a("br"),a("span",{staticClass:"line-number"},[t._v("62")]),a("br"),a("span",{staticClass:"line-number"},[t._v("63")]),a("br"),a("span",{staticClass:"line-number"},[t._v("64")]),a("br"),a("span",{staticClass:"line-number"},[t._v("65")]),a("br"),a("span",{staticClass:"line-number"},[t._v("66")]),a("br"),a("span",{staticClass:"line-number"},[t._v("67")]),a("br"),a("span",{staticClass:"line-number"},[t._v("68")]),a("br"),a("span",{staticClass:"line-number"},[t._v("69")]),a("br")])]),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IExpression")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("concatFilterByDevice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" devices"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FilterOperator")]),t._v(" operator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n输入：去重后的 devices 列表和未拼接的 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FilterOperator")]),t._v("\n输入：经过拼接后的 deviceToFilterMap，记录了每个设备对应的 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Filter")]),t._v(" 信息\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[a("code",[t._v("concatFilterByDevice()")]),t._v(" 方法按设备对过滤条件进行拼接，得到每个设备对应的过滤条件，其主要处理逻辑在 "),a("code",[t._v("concatFilterPath()")]),t._v(" 中：")]),t._v(" "),a("p",[a("code",[t._v("concatFilterPath()")]),t._v(" 方法遍历未拼接的 FilterOperator 二叉树，判断节点是否为叶子节点，如果是，则取该叶子结点的路径，如果路径以 time 或 root 开头则不做处理，否则将设备名与节点路径进行拼接后返回；如果不是，则对该节点的所有子节点进行迭代处理。")]),t._v(" "),a("p",[t._v("示例中，设备 1 过滤条件拼接后的结果为 "),a("code",[t._v("time = 1 AND root.sg.d1.s1 < 25")]),t._v("，设备 2 为 "),a("code",[t._v("time = 1 AND root.sg.d2.s1 < 25")]),t._v("。")]),t._v(" "),a("p",[t._v("下面用示例总结一下通过该阶段计算得到的变量信息：")]),t._v(" "),a("ul",[a("li",[t._v("measurement 列表 "),a("code",[t._v("measurements")]),t._v("："),a("code",[t._v("[s1, '1', s1, s2, s2, s5]")])]),t._v(" "),a("li",[t._v("measurement 类型 "),a("code",[t._v("measurementTypeMap")]),t._v("：\n"),a("ul",[a("li",[a("code",[t._v("s1 -> Exist")])]),t._v(" "),a("li",[a("code",[t._v("s2 -> Exist")])]),t._v(" "),a("li",[a("code",[t._v("s5 -> NonExist")])])])]),t._v(" "),a("li",[t._v("每个设备的过滤条件 "),a("code",[t._v("deviceToFilterMap")]),t._v("：\n"),a("ul",[a("li",[a("code",[t._v("root.sg.d1 -> time = 1 AND root.sg.d1.s1 < 25")])]),t._v(" "),a("li",[a("code",[t._v("root.sg.d2 -> time = 1 AND root.sg.d2.s1 < 25")])])])])]),t._v(" "),a("h3",{attrs:{id:"构造表头-columnheader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造表头-columnheader"}},[t._v("#")]),t._v(" 构造表头 (ColumnHeader)")]),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.service.TSServiceImpl")])]),t._v(" "),a("p",[t._v("在生成物理计划后，则可以执行 TSServiceImpl 中的 executeQueryStatement() 方法生成结果集并返回，其中第一步是构造表头。")]),t._v(" "),a("p",[t._v("按设备对齐查询在调用 "),a("code",[t._v("TSServiceImpl.getQueryColumnHeaders()")]),t._v(" 方法后，根据查询类型进入 "),a("code",[t._v("TSServiceImpl.getAlignByDeviceQueryHeaders()")]),t._v(" 来构造表头。")]),t._v(" "),a("p",[a("code",[t._v("getAlignByDeviceQueryHeaders()")]),t._v(" 方法声明如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAlignByDeviceQueryHeaders")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AlignByDevicePlan")]),t._v(" plan"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" respColumns"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" columnTypes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n输入：当前执行的物理计划 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AlignByDevicePlan")]),t._v(" 和需要输出的列名 respColumns 以及其对应的数据类型 columnTypes\n输出：计算得到的列名 respColumns 和数据类型 columnTypes\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("其具体实现逻辑如下：")]),t._v(" "),a("ol",[a("li",[t._v("首先加入 "),a("code",[t._v("Device")]),t._v(" 列，其数据类型为 "),a("code",[t._v("TEXT")]),t._v("；")]),t._v(" "),a("li",[t._v("遍历未去重的 measurements 列表，判断当前遍历 measurement 的类型，如果是 "),a("code",[t._v("Exist")]),t._v(" 类型则从 "),a("code",[t._v("columnDataTypeMap")]),t._v(" 中取得其类型；其余两种类型设其类型为 "),a("code",[t._v("TEXT")]),t._v("，然后将 measurement 及其类型加入表头数据结构中。")]),t._v(" "),a("li",[t._v("根据中间变量 "),a("code",[t._v("deduplicatedMeasurements")]),t._v(" 对 measurements 进行去重。")])]),t._v(" "),a("p",[t._v("最终得到的 Header 为：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Time")]),t._v(" "),a("th",[t._v("Device")]),t._v(" "),a("th",[t._v("s1")]),t._v(" "),a("th",[t._v("1")]),t._v(" "),a("th",[t._v("s1")]),t._v(" "),a("th",[t._v("s2")]),t._v(" "),a("th",[t._v("s2")]),t._v(" "),a("th",[t._v("s5")])])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("p",[t._v("去重后的 "),a("code",[t._v("measurements")]),t._v(" 为 "),a("code",[t._v("[s1, '1', s2, s5]")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"结果集生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结果集生成"}},[t._v("#")]),t._v(" 结果集生成")]),t._v(" "),a("p",[t._v("生成 ColumnHeader 后，最后一步为生成结果集填充结果并返回。")]),t._v(" "),a("h4",{attrs:{id:"结果集创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结果集创建"}},[t._v("#")]),t._v(" 结果集创建")]),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.service.TSServiceImpl")])]),t._v(" "),a("p",[t._v("该阶段需要调用 "),a("code",[t._v("TSServiceImpl.createQueryDataSet()")]),t._v(" 创建一个新的结果集，这部分实现逻辑较为简单，对于 AlignByDeviceQuery 而言，只需要新建一个 "),a("code",[t._v("AlignByDeviceDataSet")]),t._v(" 即可，在构造函数中将把 AlignByDevicePlan 中的参数赋值到新建的结果集中。")]),t._v(" "),a("h4",{attrs:{id:"结果集填充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结果集填充"}},[t._v("#")]),t._v(" 结果集填充")]),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.utils.QueryDataSetUtils")])]),t._v(" "),a("p",[t._v("接下来需要填充结果，AlignByDeviceQuery 将调用 "),a("code",[t._v("TSServiceImpl.fillRpcReturnData()")]),t._v(" 方法，然后根据查询类型进入 "),a("code",[t._v("QueryDataSetUtils.convertQueryDataSetByFetchSize()")]),t._v(" 方法。")]),t._v(" "),a("p",[a("code",[t._v("convertQueryDataSetByFetchSize()")]),t._v(" 方法中获取结果的重要方法为 QueryDataSet 的 "),a("code",[t._v("hasNext()")]),t._v(" 方法。")]),t._v(" "),a("p",[a("code",[t._v("hasNext()")]),t._v(" 方法的主要逻辑如下：")]),t._v(" "),a("ol",[a("li",[t._v("判断是否有规定行偏移量 "),a("code",[t._v("rowOffset")]),t._v("，如果有则跳过需要偏移的行数；如果结果总行数少于规定的偏移量，则返回 false。")]),t._v(" "),a("li",[t._v("判断是否有规定行数限制 "),a("code",[t._v("rowLimit")]),t._v("，如果有则比较当前输出行数，当前输出行数大于行数限制则返回 false。")]),t._v(" "),a("li",[t._v("进入 "),a("code",[t._v("AlignByDeviceDataSet.hasNextWithoutConstraint()")]),t._v(" 方法")])]),t._v(" "),a("br"),t._v(" "),a("ul",[a("li",[t._v("org.apache.iotdb.db.query.dataset.AlignByDeviceDataSet")])]),t._v(" "),a("p",[t._v("首先解释一下结果集中重要字段的含义：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("deviceIterator")]),t._v("：按设备对齐查询本质上是计算出每个设备对应的映射值和过滤条件，然后将查询按设备分别进行，该字段即为设备的迭代器，每次查询获取一个设备进行。")]),t._v(" "),a("li",[a("code",[t._v("currentDataSet")]),t._v("：该字段代表了本次对某设备查询所获得的结果集。")])]),t._v(" "),a("p",[a("code",[t._v("hasNextWithoutConstraint()")]),t._v(" 方法所做的工作主要是判断当前结果集是否有下一结果，没有则获取下一设备，计算该设备执行查询需要的路径、数据类型及过滤条件，然后按其查询类型执行具体的查询计划后获得结果集，直至没有设备可进行查询。")]),t._v(" "),a("p",[t._v("其具体实现逻辑如下：")]),t._v(" "),a("ol",[a("li",[t._v("首先判断当前结果集是否被初始化且有下一个结果，如果是则直接返回 true，即当前可以调用 "),a("code",[t._v("next()")]),t._v(" 方法获取下一个 "),a("code",[t._v("RowRecord")]),t._v("；否则设置结果集未被初始化进入步骤 2.")]),t._v(" "),a("li",[t._v("迭代 "),a("code",[t._v("deviceIterator")]),t._v(" 获取本次执行需要的设备，之后通过设备路径在 MManager 中查询到该设备节点，并取得该设备节点下的所有传感器节点，保存为 "),a("code",[t._v("measurementOfGivenDevice")]),t._v(".")]),t._v(" "),a("li",[t._v("遍历当前查询中的所有 measurement，将其与执行设备的所有传感器节点进行比较，得到该设备需要查询的列 "),a("code",[t._v("executeColumns")]),t._v(". 之后拼接当前设备名与 measurements，计算当前设备的查询路径、数据类型及过滤条件，得到对应的字段分别为 "),a("code",[t._v("executePaths")]),t._v(", "),a("code",[t._v("tsDataTypes")]),t._v(", "),a("code",[t._v("expression")]),t._v("，如果是聚合查询，则还需要计算 "),a("code",[t._v("executeAggregations")]),t._v("。")]),t._v(" "),a("li",[t._v("判断当前子查询类型为 GroupByQuery, AggregationQuery, FillQuery 或 RawDataQuery 进行对应的查询并返回结果集，实现逻辑可参考 "),a("RouterLink",{attrs:{to:"/zh/SystemDesign/DataQuery/RawDataQuery.html"}},[t._v("原始数据查询")]),t._v("，"),a("RouterLink",{attrs:{to:"/zh/SystemDesign/DataQuery/AggregationQuery.html"}},[t._v("聚合查询")]),t._v("，"),a("RouterLink",{attrs:{to:"/zh/SystemDesign/DataQuery/GroupByQuery.html"}},[t._v("降采样查询")]),t._v("。")],1)]),t._v(" "),a("p",[t._v("通过 "),a("code",[t._v("hasNextWithoutConstraint()")]),t._v(" 方法初始化结果集并确保有下一结果后，则可调用 "),a("code",[t._v("QueryDataSet.next()")]),t._v(" 方法获取下一个 "),a("code",[t._v("RowRecord")]),t._v(".")]),t._v(" "),a("p",[a("code",[t._v("next()")]),t._v(" 方法主要实现逻辑为 "),a("code",[t._v("AlignByDeviceDataSet.nextWithoutConstraint()")]),t._v(" 方法。")]),t._v(" "),a("p",[a("code",[t._v("nextWithoutConstraint()")]),t._v(" 方法所做的工作主要是"),a("strong",[t._v("将单个设备查询所得到的按时间对齐的结果集形式变换为按设备对齐的结果集形式")]),t._v("，并返回变换后的 "),a("code",[t._v("RowRecord")]),t._v("。")]),t._v(" "),a("p",[t._v("其具体实现逻辑如下：")]),t._v(" "),a("ol",[a("li",[t._v("首先从结果集中取得下一个按时间对齐的 "),a("code",[t._v("originRowRecord")]),t._v("。")]),t._v(" "),a("li",[t._v("新建一个添加了时间戳的 "),a("code",[t._v("RowRecord")]),t._v("，向其中加入设备列，先根据 "),a("code",[t._v("executeColumns")]),t._v(" 与得到的结果建立一个由 "),a("code",[t._v("measurementName -> Field")]),t._v(" 的 Map 结构 "),a("code",[t._v("currentColumnMap")]),t._v(".")]),t._v(" "),a("li",[t._v("之后只需要遍历去重后的 "),a("code",[t._v("measurements")]),t._v(" 列表，判断其类型，如果类型为 "),a("code",[t._v("Exist")]),t._v(" 则根据 measurementName 从 "),a("code",[t._v("currentColumnMap")]),t._v(" 中取得其对应的结果，如果没有则设为 "),a("code",[t._v("null")]),t._v("；如果是 "),a("code",[t._v("NonExist")]),t._v("类型，则直接设为 "),a("code",[t._v("null")]),t._v("。")])]),t._v(" "),a("p",[t._v("再根据变换后的 "),a("code",[t._v("RowRecord")]),t._v(" 写入输出数据流后，即可将结果集返回。")])])}),[],!1,null,null,null);s.default=e.exports}}]);